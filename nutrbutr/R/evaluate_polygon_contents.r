#' evaluate raster values contained within polygons
#' 
#' @depends raster
#' @param raster_input a raster object
#' @param polygon_input a SpatialPolygonsDataFrame object
#' @param task a function to peform on the many raster values
#' @return the list of values associated with the function operated on the raster contents of each polygon
#' 
#' 
evaluate_polygon_contents <- function(raster_input,polygon_input, task = mean){
  if (is.na(proj4string(raster_input))){
    stop("No projection specified for raster input")
  }
  if (is.na(proj4string(polygon_input))){
    stop("No projection specified for polygon input")
  }
  if ( proj4string(polygon_input) != proj4string(raster_input) ){
    stop("The projection differs between the raster and polygon inputs")
  }
  V <- raster::extract(raster_input, polygon_input)
  V.task <- unlist(lapply(V,function(x) if (!is.null(x)) task(x) else NA))
  return(V.task)
}


# Evaluating Polygon Contents in chunks to avoid memory overload
#' 
#' @depends raster
#' @param raster_object a raster object
#' @param SpPolyDF a SpatialPolygonsDataFrame object
#' @param breaks the number of chunks in which to process the operation
#' @return storage a vector values generated by running evaluate_polygon_contents
#' 
evaluate_polygon_contents_by_chunks <- function(raster_object, SpPolyDF, breaks = 20){
  n = dim(SpPolyDF)[1] # Check the dimension of the of teh SpatialPolygonDataFrame
  x = 1:n # Create and index
  x = split(x, ceiling(seq_along(x)/breaks)) # Split that index into a set of subindex
  storage = c() # initiatlize a storage vector
  for (i in x){
    print(i)
    partial_results = evaluate_polygon_contents(rater_input = raster_object, 
                                                polygon_input = SpPolyDF[i ,], 
                                                task = mode)
    storage <- c(storage, partial_results)
  } 
  return(storage)
}

